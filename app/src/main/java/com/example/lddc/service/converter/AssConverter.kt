package com.example.lddc.service.converter

import android.annotation.SuppressLint
import com.example.lddc.service.parser.LyricsLine
import com.example.lddc.service.parser.MultiLyricsData

/**
 * ASS 字幕转换器（Advanced SubStation Alpha）
 *
 * 将歌词数据转换为ASS格式字幕
 * ASS是高级字幕格式，支持更丰富的样式和卡拉OK效果
 *
 * 特性：
 * - 支持多语言分层显示
 * - 支持卡拉OK效果（{\kf}标签）
 * - 可自定义字体、颜色、位置等样式
 *
 * 对应 Python 中的 core/converter/ass.py
 */

/**
 * ASS文件头第一部分
 *
 * 包含脚本信息和生成工具标识
 */
private fun getAssHeader1(version: String = "1.0") = """[Script Info]
; Script generated by LDDC $version
; https://github.com/chenmozhijin/LDDC
"""

/**
 * ASS文件头第二部分
 *
 * 包含脚本类型和样式格式定义
 */
private val ASS_HEADER2 = """ScriptType: v4.00+
Timer: 100.0000

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
"""

/**
 * ASS对话行模板
 *
 * 格式：Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
 */
private const val DIALOGUE = "Dialogue: 0,%s,%s,%s,,0,0,0,,%s\n"

/**
 * 将毫秒转换为ASS时间戳格式
 *
 * ASS时间戳格式：H:MM:SS.cc（时:分:秒.百分秒）
 *
 * @param ms 毫秒数
 * @return ASS格式时间戳（如"0:01:23.45"）
 */
@SuppressLint("DefaultLocale")
fun ms2assTimestamp(ms: Long): String {
    val hours = ms / 3600000
    val minutes = (ms % 3600000) / 60000
    val seconds = (ms % 60000) / 1000
    val centiseconds = (ms % 1000) / 10

    return String.format("%d:%02d:%02d.%02d", hours, minutes, seconds, centiseconds)
}

/**
 * 将歌词行转换为ASS文本
 *
 * 如果歌词包含逐字时间戳，则生成卡拉OK效果（{\kf}标签）
 * 否则直接返回纯文本
 *
 * @param lyricsLine 歌词行
 * @return ASS格式的歌词文本
 */
fun lyricsLine2asstext(lyricsLine: LyricsLine): String {
    // 单行歌词直接返回文本
    if (lyricsLine.words.size == 1) {
        return lyricsLine.words.joinToString("") { it.text }
    }

    // 多字歌词生成卡拉OK效果
    val sb = StringBuilder()
    for (word in lyricsLine.words) {
        if (word.start != null && word.end != null) {
            // \kf 标签：卡拉OK效果，参数为持续时间（百分秒）
            val k = kotlin.math.abs(word.end - word.start) / 10
            sb.append("{\\kf$k}${word.text}")
        } else {
            // 没有时间戳，返回纯文本
            return lyricsLine.words.joinToString("") { it.text }
        }
    }
    return sb.toString()
}

/**
 * 将歌词数据转换为ASS格式字符串
 *
 * @param title 歌曲标题（可选，显示在文件头）
 * @param lyricsDict 多语言歌词数据（orig原文, ts翻译, roma罗马音）
 * @param langsMapping 语言行号映射
 * @param langsOrder 语言输出顺序（决定图层顺序）
 * @param duration 歌曲时长（毫秒）
 * @param version 版本号
 * @return ASS格式字符串
 */
fun assConverter(
    title: String?,
    lyricsDict: MultiLyricsData,
    langsMapping: Map<String, Map<Int, Int>>,
    langsOrder: List<String>,
    duration: Long? = null,
    version: String = "1.0"
): String {
    val sb = StringBuilder()

    // 添加文件头
    sb.append(getAssHeader1(version))
    if (!title.isNullOrEmpty()) {
        sb.appendLine("Title: $title")
    }
    sb.append(ASS_HEADER2)

    // 添加样式定义（每种语言一个样式）
    val styles = langsOrder.map { lang ->
        "Style: $lang,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1"
    }
    sb.appendLine(styles.joinToString("\n"))
    sb.appendLine()

    // 添加事件头
    sb.appendLine("[Events]")
    sb.appendLine("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text")

    // 获取原始歌词并补充完整时间戳
    val origLyrics = lyricsDict["orig"] ?: return sb.toString()
    val fullTimestampsLyrics = getFullTimestampsLyricsData(
        origLyrics,
        duration = duration,
        onlyLine = true
    )

    // 按语言顺序生成对话行
    val lyricsTexts = mutableMapOf<String, StringBuilder>()
    langsOrder.reversed().forEach { lang ->
        lyricsTexts[lang] = StringBuilder()
    }

    for (origIndex in fullTimestampsLyrics.indices) {
        val origLine = fullTimestampsLyrics[origIndex]
        if (origLine.start == null || origLine.end == null) continue

        val start = ms2assTimestamp(origLine.start)
        val end = ms2assTimestamp(origLine.end)

        val lyricsLines = getLyricsLines(lyricsDict, langsOrder, origIndex, origLine, langsMapping)

        for ((lyricsLine, _) in lyricsLines) {
            val text = lyricsLine2asstext(lyricsLine)
            // 根据歌词行的语言添加到对应的文本
            val lang = langsOrder.find { l ->
                lyricsDict[l]?.any { it.start == lyricsLine.start && it.getText() == lyricsLine.getText() } == true
            } ?: "orig"
            lyricsTexts[lang]?.append(String.format(DIALOGUE, start, end, lang, text))
        }
    }

    // 按语言顺序追加到结果（反转顺序使原文在最上层）
    langsOrder.reversed().forEach { lang ->
        sb.append(lyricsTexts[lang])
    }

    return sb.toString()
}
